<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ELDEN RING NIGNTREIGN 遺物組み合わせ(ビルド)探索ツール</title>
<meta name="description" content="ELDEN RING NIGHTREIGN（ナイトレイン）の遺物を登録し、欲しい効果をできる限り実現できる組み合わせを探索するためのツール。">
<meta name="keywords" content="ELDEN RING NIGHTREIGN,ナイトレイン,NIGHTREIGN,遺物,Relic,Relics,シミュレーター,ビルド,探索,組み合わせ,最適化">
<meta name="robots" content="index, follow">
<!-- favicon -->
<link rel="icon" type="image/png" href="favicon/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/svg+xml" href="favicon/favicon.svg">
<link rel="shortcut icon" href="favicon/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
<meta name="apple-mobile-web-app-title" content="Nightreign Relic Simulator">
<link rel="manifest" href="favicon/site.webmanifest">

<!-- canonical -->
<link rel="canonical" href="https://17number.github.io/enr-relics-simulator/">

<!-- 構造化データ -->
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "ENR Relics Simulator",
    "url": "https://17number.github.io/enr-relics-simulator/",
    "applicationCategory": "Utility",
    "operatingSystem": "Web",
    "description": "ELDEN RING NIGHTREIGN の遺物を登録し、欲しい効果を実現できる組み合わせを探索するウェブツール。",
    "author": {
      "@type": "Person",
      "name": "17number"
    }
  }
</script>

<!-- goat counter -->
<script data-goatcounter="https://enr-relics-simulator.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>

<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;margin:16px;background:#f6f7fb;color:#111}
  h1{margin:0 0 12px;font-size:20px}
  .row{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;margin-bottom:2rem}
  .panel{background:#fff;border-radius:8px;padding:12px;box-shadow:0 2px 6px rgba(0,0,0,0.06);min-width:280px}
  .panel button {
    font-size: 13px;
    padding: 4px 8px;
    border-radius: 6px;
    transition: all 0.15s;
  }
  .panel > div[style*="margin-bottom:8px"] {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }
  select,input,button,textarea{font-size:14px;padding:6px;border:1px solid #ddd;border-radius:6px}
  button{cursor:pointer}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#eee;margin:4px}
  .color-chip{width:14px;height:14px;border-radius:4px;display:inline-block;margin-right:2px}
  .color-y{background:#f6c34a} .color-g{background:#7cc47b} .color-b{background:#6fa3ff}
  .color-r{background:#f08080} .color-grey{background:#cfcfcf}
  .bg-y { background: #fcf3d5; }
  .bg-g { background: #e5f2e4; }
  .bg-b { background: #e3ecff; }
  .bg-r { background: #f9e1e1; }
  .bg-grey{background:#cfcfcf30}
  .bg-w{background:#fff}
  .character-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: start;
    margin-bottom: 8px;
  }
  .character-card {
    flex: 0 1 auto;
    width: 80px;
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 6px;
    text-align: center;
    cursor: pointer;
    background: #fff;
    transition: background 0.15s, border-color 0.15s, transform 0.15s;
  }
  .character-card.active {
    background: #5ab2;
    border: 1px solid #028;
  }
  .character-card:hover {
    opacity: 0.8;
    border-color: #5ab;
    transform: translateY(-1px);
  }
  .character-card input {
    display: none;
  }
  .character-card input:checked + .character-name {
    color: #024;
    font-weight: 600;
  }
  .character-name {
    display: block;
    user-select: none;
    font-size: 13px;
  }
  .effect-list, .disadvantage-list{padding-left:1.25rem;margin:0;}
  .effect-row, .disadvantage-row{display:flex;gap:8px;align-items:center;margin:6px 0}
  .effect-row .ts-wrapper, .disadvantage-row .ts-wrapper {width: 70vw}
  .effect-row .btn-secondary,
  .disadvantage-row .btn-secondary {
    background: #fff;
    border: 1px solid #ccc;
    color: #333;
  }
  .effect-row button:not(:first-child),
  .disadvantage-row button:not(:first-child) {
    margin-left: 4px;
  }
  .effect-row .btn-secondary:hover,
  .disadvantage-row .btn-secondary:hover {
    border-color: #999;
    background: #f5f5f5;
  }
  .effect-row .btn-secondary[id*="remove"],
  .disadvantage-row .btn-secondary[id*="remove"],
  #resetDesiredBtn, #resetExcludedBtn, #clearResultsBtn,
  #inventoryList .relic-item .btn-secondary[data-id] {
    color: #c33;
    border-color: #c33;
  }
  .effect-row .btn-secondary[id*="remove"]:hover,
  .disadvantage-row .btn-secondary[id*="remove"]:hover,
  #resetDesiredBtn:hover, #resetExcludedBtn:hover, #clearResultsBtn:hover,
  #inventoryList .relic-item .btn-secondary[data-id] {
    background: #fdd;
  }
  #addDesiredBtn, #addExcludedBtn, #openAddRelic,
  #importCsvOverwrite, #importCsvAppendStart, #importCsvAppendEnd {
    background: #2b6cb0;
    color: #fff;
    border: none;
  }
  #addDesiredBtn:hover, #addExcludedBtn:hover, openAddRelic:hover,
  #importCsvOverwrite:hover, #importCsvAppendStart:hover, #importCsvAppendEnd:hover {
    background: #1d4f91;
  }
  .result-card {
    border: 1px solid #ddd;
    background: #fffefc;
    padding: 8px;
    border-radius: 8px;
    margin: 8px 0;
    transition: background 0.2s, border-color 0.2s;
  }
  .result-card:nth-child(even) {
    border-color: #bbb;
    background: #0001;
  }
  .relic-item{display:flex;align-items:center;gap:8px;margin:6px 0;padding:6px;border:1px solid #bbb;border-radius:6px}
  .advantage.desired{color: #f19; font-weight: 600;}
  .disadvantage{margin-left: 4px; color: #2b6cb0}
  .heading{
    font-size: 14px;
    font-weight: 600;
    color: #333;
    display: block;
    margin: 12px 0 6px;
    padding: 4px 0;
    border-left: 4px solid #5ab;
    padding-left: 6px;
    background: #f8fafc;
    border-radius: 2px;
  }
  .small{font-size:13px;color:#555}
  .tiny{font-size:10px;color:#aaa}
  .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .muted{color:#666;font-size:13px}
  .btn-secondary{background:#fff;border:1px solid #ddd}
  .btn-primary{background:#2b6cb0;color:#fff;border:none}
  .btn-secondary:disabled,
  .btn-primary:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }
  .footer{margin-top:12px;color:#666;font-size:13px}
  label{display:block;font-size:13px;margin-bottom:6px}
  #importRelicsModal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:80;align-items:center;justify-content:center}
  #resultsArea{}
  .tab-header {
    display: flex;
    gap: 8px;
  }
  .tab-btn {
    padding: 8px 16px;
    background: #eee;
    border: 1px solid #ccc;
    border-radius: 6px 6px 0 0;
    cursor: pointer;
  }
  .tab-btn.active {
    background: #fff;
    border-bottom: 1px solid #fff;
    font-weight: bold;
  }
  .tab-content {
    display: none;
  }
  .tab-content.active {
    display: block;
  }
</style>
<!-- JSON5 for browser -->
<script src="https://cdn.jsdelivr.net/npm/json5@2.2.3/dist/index.min.js"></script>
<!-- Tom Select -->
<link href="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/css/tom-select.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/js/tom-select.complete.min.js"></script>
<!-- Paraparse -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.5.3/papaparse.min.js"></script>
<!-- fuse.js -->
<script src="https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.min.js"></script>
<!-- ULID -->
<script src="https://cdn.jsdelivr.net/npm/ulid@2.4.0/dist/index.umd.min.js"></script>
<!-- dayjs -->
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
<!-- Tonejs -->
<script src="https://cdn.jsdelivr.net/npm/tone@15.1.22/build/Tone.min.js"></script>
</head>
<body>
<h1>ELDEN RING NIGNTREIGN 遺物組み合わせ(ビルド)探索ツール</h1>

<!-- ▼ タブヘッダー -->
<div class="tab-header">
  <button class="tab-btn" data-tab="searchTab">ビルド探索</button>
  <button class="tab-btn" data-tab="inventoryTab">所持遺物</button>
  <button class="tab-btn" data-tab="usageTab">使い方</button>
</div>

<div class="tab-content" id="searchTab">
  <div class="row">
    <div class="panel" style="flex:1 1 360px">
      <label class="heading">1: キャラクターを選択</label>
      <div id="characterList" class="character-grid"></div>
      <hr />

      <label class="heading">2: 欲しい遺物効果（最大18件）</label>
      <div style="margin-bottom:8px">
        <button id="addDesiredBtn" class="btn-secondary">＋ 効果を追加</button>
        <button id="resetDesiredBtn" class="btn-secondary">リセット</button>
      </div>
      <div id="desiredList"></div>
      <div style="margin-bottom:8px">
        <button id="addDesiredBtn" class="btn-secondary">＋ 効果を追加</button>
        <button id="resetDesiredBtn" class="btn-secondary">リセット</button>
      </div>
      <hr />

      <label class="heading">3: 除外したいデメリット効果</label>
      <div style="margin-bottom:8px">
        <button id="addExcludedBtn" class="btn-secondary">＋ 除外デメリットを追加</button>
        <button id="resetExcludedBtn" class="btn-secondary">リセット</button>
      </div>
      <div id="excludedList"></div>
      <div style="margin-bottom:8px">
        <button id="addExcludedBtn" class="btn-secondary">＋ 除外デメリットを追加</button>
        <button id="resetExcludedBtn" class="btn-secondary">リセット</button>
      </div>
      <hr />

      <label class="heading">4: 実行</label>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button id="searchBtn" class="btn-primary">探索開始</button>
        <button id="clearResultsBtn" class="btn-secondary">結果クリア</button>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="panel" style="flex:1 1 360px">
      <label>探索結果</label>
      <div id="statusArea" class="muted"></div>
      <div id="resultsArea" class="muted">まだ探索していません</div>
    </div>
  </div>
</div>

<div class="tab-content" id="inventoryTab">
  <div class="row">
    <div class="panel" style="flex:1 1 360px">
      <label>所持遺物（ユーザー登録・検索）</label>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <input id="inventorySearch" placeholder="ID/効果名/かな/色(r/g/b/y)/大きさ(s/m/l)/遺物種類(n/d)を検索" style="flex:1" />
        <button id="openAddRelic" class="btn-secondary">＋ 所持遺物を登録</button>
      </div>
      <div id="inventoryList" class="muted">所持遺物読み込み中...</div>
    </div>
  </div>
</div>

<div class="tab-content" id="usageTab">
  <div class="panel">
    <h3>ツール概要</h3>
    <p>
      本ツールは <strong>ELDEN RING NIGHTREIGN</strong> に登場する「遺物」を登録し、<br>
      <strong>欲しい効果をできる限り実現できる組み合わせ</strong> を探索するための支援ツールです。
    </p>

    <h4>使い方</h4>
    <ol>
      <li>
        <a href="https://github.com/17number/enr-relics-importer" target="_blank" rel="noopener">
          別ツール（enr-relics-importer）
        </a>
        を使用して、所持遺物の一覧 CSV を作成します。
      </li>
      <li>
        「<strong>所持遺物</strong>」タブの「<strong>＋ 所持遺物を登録</strong>」ボタンから遺物一覧を登録します。
        <ul>
          <li>初回は「上書き登録」を選択してください。</li>
          <li>2回目以降に差分のみ追加したい場合は「先頭に追加」または「末尾に追加」を選択できます。</li>
        </ul>
      </li>
      <li>
        「<strong>ビルド探索</strong>」タブで、キャラクター・欲しい遺物効果・除外したいデメリット効果 を指定して探索を実行します。<br>
        条件に合う(または近しい)組み合わせを自動的に検索します。
      </li>
    </ol>

    <h4>注意事項</h4>
    <ul>
      <li><strong>必ず最適な組み合わせが見つかる保証はありません。</strong></li>
      <li><strong>データの送信や外部通信は行っていません</strong>が、<br>
          心配な方はご利用をお控えください（自己責任でお願いします）。</li>
      <li>対応言語は日本語のみです。</li>
      <li>欲しい効果を増やすほど探索時間が長くなります。最初は少数の効果で試すのをおすすめします。</li>
      <li>探索にかかる時間・速度はご利用のPCスペックに依存します。</li>
    </ul>

    <h4>その他</h4>
    <ul>
      <li>「所持遺物」タブでは、登録済みの遺物一覧を検索・管理できます。</li>
      <li>登録データはブラウザ内に保存されます（リロードや再訪問時にも復元されます）。</li>
      <li>ツールは個人制作の非公式ファンツールです。ゲーム公式・運営元とは一切関係ありません。</li>
      <li>ビルド画像を生成するための別ツール(<a href="https://17number.github.io/enr-relics-merger/" target="_blank" rel="noopener">ELDEN RING NIGHTREIGN 遺物画像結合ツール</a>)もぜひご利用ください。</li>
    </ul>

    <p style="margin-top:16px;font-size:0.9em" class="muted">
      © FromSoftware / Bandai Namco Entertainment Inc.<br>
      本ツールは非公式ツールです。
    </p>
  </div>
</div>

<!-- Add relic modal (simple) -->
<div id="importRelicsModal" style="">
  <div style="background:#fff;padding:12px;border-radius:8px;width:80vw;box-shadow:0 6px 20px rgba(0,0,0,0.25)">
    <h3 style="margin-top:0">遺物をCSVからインポート</h3>
    <p class="muted">
      <a href="#" onclick="closeRelicModal(); document.querySelector(`[data-tab='usageTab']`).click(); return false;">使い方</a>に記載されている方法で CSV を作成して選択してください。
    </p>
    <div style="display:flex;gap:8px;flex-direction:column">
      <input type="file" name="relicsCsv" id="relicsCsv" accept=".csv">
      <button id="importCsvOverwrite" data-import-mode="overwrite">上書き登録</button>
      <button id="importCsvAppendStart" data-import-mode="append-start">先頭に追加</button>
      <button id="importCsvAppendEnd" data-import-mode="append-end">末尾に追加</button>
      <button id="r_cancel" class="btn-secondary">キャンセル</button>
    </div>
  </div>
</div>

<footer style="font-size: 0.9em; margin-top: 1rem; text-align: center;">
  <a href="privacy.html" style="padding: 0; margin: 0;">プライバシーポリシー</a>
  <div id="version" style="color: #666;"></div>
</footer>

<script>
MAX_EFFECT_NUM = 18;
MAX_DISADVANTAGE_NUM = 24;

/* -----------------------
  App code: UI + data loading
------------------------- */

const FILES = [
  "master/normal_relic_effects.json5",
  "master/depth_relic_effects.json5",
  "master/depth_relic_disadvantages.json5",
  "master/chalices.json5",
  "master/relic_names.json5",
  "master/unique_relics.json5",
  "master/characters.json5",
  "master/effect_categories.json5",
  "master/effect_groups.json5",
];

let DATA = {};
let effectGroups = [];
let effectMap = {};
let normalEffects= [], depthEffects = [], allEffects = [];
let allRelics = [];
let disadvantages = [], characters = [], chalices = [], relicNames = [], uniqueRelics = [];
let userRelics = [];
let searchCondition = {};
let isSearching = false;
const expandCache = new Map();
const USER_RELICS_KEY = "my_relics";
const SEARCH_CONDITION = "search_cond";
const ACTIVE_TAB = "active_tab";
const COLOR_MAP = {
  "r": "red",
  "b": "blue",
  "y": "yellow",
  "g": "green",
  "red": "r",
  "blue": "b",
  "yellow": "y",
  "green": "g",
};
const SIZE_MAP = {
  "s": 1,
  "m": 2,
  "l": 3,
};

async function loadAll(){
  const loaded = {};
  for(const f of FILES){
    try{
      const r = await fetch(f);
      const txt = await r.text();
      loaded[f] = JSON5.parse(txt);
    }catch(e){
      console.error("failed to load", f, e);
      loaded[f] = (f.endsWith("chalices.json5")||f.endsWith("unique_relics.json5")||f.endsWith("characters.json5"))? [] : {};
    }
  }
  DATA = loaded;
  const categories = DATA[FILES.at(7)] || [];
  effectGroups = DATA[FILES.at(8)] || [];
  normalEffects = (DATA[FILES.at(0)] || []).map(e => {
    const group = effectGroups.find(g => g.normal_ids.includes(e.id));
    return {
      ...e,
      group_id: group?.id ?? null,
      text2: `[通常] ${e.text}`,
    }
  });
  depthEffects = (DATA[FILES.at(1)] || []).map(e => {
    const group = effectGroups.find(g => g.depth_ids.includes(e.id));
    return {
      ...e,
      group_id: group?.id ?? null,
      text2: `[深層] ${e.text}`,
    }
  });
  allEffects = [...normalEffects, ...depthEffects];
  effectMap = {};
  // normal & depth categories: objects keyed by category name -> arrays
  for(const eff of allEffects){
    eff.category = categories.find(cat=>cat.id === eff.category_id);
    effectMap[eff.id] = eff;
  }
  // load other files
  disadvantages = DATA[FILES.at(2)] || [];
  chalices = DATA[FILES.at(3)] || [];
  relicNames = DATA[FILES.at(4)] || [];
  uniqueRelics = DATA[FILES.at(5)] || [];
  allRelics = [...uniqueRelics, ...relicNames];
  characters = DATA[FILES.at(6)] || [];

  // load user relics from localStorage
  userRelics = loadUserRelics();
  buildUserRelicsForRender();

  // load user search condition
  loadSearchCondition();
}

function buildUserRelicsForRender() {
  userRelics = userRelics.map(r => {
    const relicObj = allRelics.find(_r => _r.id === r.relic_id);
    const _effects = r.effects.map(eid => {
      const effectObj = allEffects.find(_e => _e.id === eid);
      if (!effectObj) return null;
      return {
        id: eid,
        text: effectObj.text,
        kana: effectObj.kana,
      };
    });
    const _disadvantages = r.disadvantages.map(did => {
      const disadvandageObj = disadvantages.find(_d => _d.id === did);
      if (!disadvandageObj) return null;
      return {
        id: did,
        text: disadvandageObj.text,
        kana: disadvandageObj.kana,
      };
    });
    return {
      id: r.id,
      relic_id: r.relic_id ?? relicObj.id,
      name: relicObj.name,
      color: r.color ?? COLOR_MAP[relicObj.color],
      type: relicObj.type,
      unique: relicObj.unique,
      effects: _effects,
      disadvantages: _disadvantages,
    };
  });
}

function renderWithData() {
  renderCharacters();
  renderRelics();
  initDesiredArea();
  initExcludedArea();
}

/**
 * キャラクター選択欄
 */
function renderCharacters() {
  const list = document.getElementById("characterList");
  list.innerHTML = "";

  const initialId = searchCondition.character_id || characters[0].id;
  characters.forEach((c, idx) => {
    const label = document.createElement("label");
    label.className = "character-card";

    const input = document.createElement("input");
    input.type = "radio";
    input.name = "character";
    input.value = c.id;
    if (c.id === initialId) {
      input.checked = true;
      label.classList.add('active');
    }
    input.addEventListener("change", onCharacterChange);

    const name = document.createElement("div");
    name.className = "character-name";
    name.textContent = c.name;

    label.appendChild(input);
    label.appendChild(name);
    list.appendChild(label);
  });

  // 初期選択
  if (characters.length > 0) {
    const initialInput = list.querySelector(`input[value="${initialId}"]`);
    if (initialInput) {
      initialInput.checked = true;
    }
  }
}

/**
 * キャラクター変更時
 */
function onCharacterChange() {
  const selected = document.querySelector('input[name="character"]:checked');
  if (!selected) {
    return;
  }
  document.querySelectorAll('input[name="character"]').forEach(e => {
    e.closest('.character-card').classList.remove('active');
  });
  selected.closest('.character-card').classList.add('active');

  const id = Number(selected.value);
  const char = characters.find(c=>c.id===id);
  if (id !== searchCondition.character_id) {
    // キャラ変更時はそのキャラで前に設定していた効果やデメリットなどを復元
    searchCondition.character_id = id;
    renderDesiredRows(true);
    renderExcludedRows(true);
  }
  updateSearchCondition();
  saveSearchCondition();
}

function updateSearchCondition() {
  const selected = document.querySelector('input[name="character"]:checked');
  if (!selected) return;
  const character_id = Number(selected.value);
  const desiredSelects = Array.from(document.querySelectorAll("select[id^='desired_select_']"));
  const desiredCounts = Array.from(document.querySelectorAll("select[id^='desired_count_']"));
  const excludedSelects = Array.from(document.querySelectorAll("select[id^='excluded_select_']"));
  const effect_ids = desiredSelects.map(s => Number(s.value.trim() || 0));
  const effect_counts = desiredCounts.map(s => Number(s.value.trim() || 1));
  const disadvantage_ids = excludedSelects.map(s => Number(s.value.trim() || 0));
  searchCondition = {
    ...searchCondition,
    character_id,
    [character_id]: {
      effect_ids,
      effect_counts,
      disadvantage_ids,
    },
  }
}

/**
 * localStorage の保存データ読み込み
 */
function loadSearchCondition(){
  const raw = localStorage.getItem(SEARCH_CONDITION);
  if (raw) {
    searchCondition = JSON.parse(raw);
  } else {
    searchCondition = {
      character_id: 1,
    };
    characters.forEach(char => searchCondition[char.id] = {
      effect_ids: [0],
      effect_counts: [1],
      disadvantage_ids: [],
    });
  }
  return searchCondition;
}

/**
 * localStorage に保存
 */
function saveSearchCondition(){
  localStorage.setItem(
    SEARCH_CONDITION,
    JSON.stringify(searchCondition),
  );
}

/**
 * localStorage の保存データ読み込み
 */
function loadUserRelics(){
  const raw = localStorage.getItem(USER_RELICS_KEY);
  userRelics = raw ? JSON.parse(raw) : [];
  return userRelics
}

/**
 * localStorage に保存
 */
function saveUserRelics(){
  localStorage.setItem(
    USER_RELICS_KEY,
    JSON.stringify(
      (userRelics||[])
        .map(r => ({
          id: r.id,
          color: r.color,
          relic_id: r.relic_id,
          effects: r.effects,
          disadvantages: r.disadvantages,
        }))
    ),
  );
}

/**
 * テキストの近いものを取得
 */
function findClosest(text, list, key) {
  const fuse = new Fuse(list, { keys: [key], threshold: 0.3 });
  try {
    const res = fuse.search(text);
    return res.length > 0 ? res[0].item : null;
  } catch (e) {
    console.error(e)
  }
}

/**
 * テキストで遺物効果などを検索
 */
function findByText(text, list, key = "text") {
  const exact = list.find(item => item[key] === text);
  if (exact) return exact;
  return findClosest(text, list, key);
}

/**
 * CSV 取り込み
 */
async function importCSV(file, mode) {
  const csvText = await file.text();
  const parsed = Papa.parse(csvText, { header: true }).data;

  const imported = [];

  for (const row of parsed) {
    if (!row.Name) continue;

    const relicObj = findByText(row.Name, allRelics, "name");
    const color = row.Color ? row.Color[0].toLowerCase() : "";

    const _effects = [];
    const _disadvantages = [];

    const candEffects = relicObj.type === "normal" ? normalEffects : depthEffects;
    const candDisadvantages = relicObj.type === "normal" ? [] : disadvantages;

    for (let i = 1; i <= 3; i++) {
      const e = row[`Effect${i}`]?.trim();
      if (!e) {
        _effects.push(0);
      } else {
        const match = findByText(e, candEffects);
        if (match) _effects.push(match.id);
        else _effects.push(0);
      }

      const d = row[`Disadvantage${i}`]?.trim();
      if (!d) {
        _disadvantages.push(0);
      } else {
        const match = findByText(d, candDisadvantages);
        if (match) _disadvantages.push(match.id);
        else _disadvantages.push(0);
      }
    }

    imported.push({
      id: ULID.ulid(),
      relic_id: relicObj?.id ?? null,
      color,
      effects: _effects,
      disadvantages: _disadvantages,
    });
  }

  // --- localStorage 保存処理 ---
  if (mode === "overwrite") {
    userRelics = imported;
  } else {
    const existingRelics = userRelics.map(r => ({
      id: r.id,
      relic_id: r.relic_id,
      color: r.color[0],
      effects: r.effects.map(e => e?.id ?? 0),
      disadvantages: r.disadvantages.map(d => d?.id ?? 0),
    }));
    if (mode === "append-start") {
      userRelics = [
        ...imported,
        ...existingRelics,
      ]
    }
    else {
      userRelics = [
        ...existingRelics,
        ...imported,
      ]
    }
  }

  saveUserRelics();
  buildUserRelicsForRender();
  renderRelics();

  console.table(imported);
  console.debug(`✅ ${imported.length} 件インポート完了\n\n例:\n${JSON.stringify(imported.slice(0, 3), null, 2)}`);

  clearImportCsvFile();
  closeRelicModal();
}

document.querySelectorAll(`[id*="importCsv"]`)
  .forEach(btn =>
    btn.addEventListener("click", async (event) => {
      const fileInput = document.getElementById("relicsCsv");
      const file = fileInput.files[0];
      if (!file) return alert("CSVファイルを選択してください。");

      const mode = event.target.dataset.importMode;
      await importCSV(file, mode);
    }));

/* -----------------------
  Desired effects area (dynamic rows with incremental search)
------------------------- */
let desiredRowIndex = 0;
let excludedRowIndex = 0;

/**
 * 探索対象遺物効果の初期化
 */
function initDesiredArea(){
  const container = document.getElementById("desiredList");
  container.innerHTML = "";
  document.querySelectorAll("#addDesiredBtn").forEach(e => e.addEventListener("click", () => {
    addDesiredRow();
    updateSearchCondition();
    saveSearchCondition();
  }));
  document.querySelectorAll("#resetDesiredBtn").forEach(e => e.addEventListener("click", ()=> {
    container.innerHTML = "";
    addDesiredRow();
    updateSearchCondition();
    saveSearchCondition();
  }));

  // 前回の設定を復元
  renderDesiredRows();
}

function resetEffectNumbers() {
  const container = document.getElementById("desiredList");
  Array.from(container.children).forEach((e, i) => {
    e.querySelector("span[id^='desired_number_']").textContent = i + 1;
  });
}

/**
 * 探索対象遺物効果の追加
 */
function addDesiredRow(){
  const container = document.getElementById("desiredList");
  if (container.children.length >= MAX_EFFECT_NUM) {
    return;
  }

  const idx = desiredRowIndex++;
  const wrapper = document.createElement("div");
  wrapper.className = "effect-row";
  wrapper.style.position = "relative";
  wrapper.id = "desired_row_"+idx;
  wrapper.innerHTML = `
    <span id="desired_number_${idx}" class="small" style="width: 0.9rem;">${container.children.length + 1}</span>
    <select id="desired_select_${idx}" placeholder="効果を選択(名前/かな 入力で候補表示)" style="flex:1" data-idx="${idx}"></select>
    <select id="desired_count_${idx}" title="個数">
      ${[1,2,3].map(n=>`<option value="${n}">x${n}</option>`).join('')}
    </select>
    <button class="btn-secondary" id="desired_remove_${idx}">削除</button>
    <button class="btn-secondary" id="desired_upto_${idx}">↑</button>
    <button class="btn-secondary" id="desired_downto_${idx}">↓</button>
  `;
  container.appendChild(wrapper);
  new TomSelect(`select#desired_select_${idx}`, {
    options: allEffects,
    valueField: 'id',
    labelField: 'text2',
    searchField: ['text', 'kana'],
    maxItems: 1,
    maxOptions: null,
    plugins: ['remove_button'],
    create: false,
    placeholder: '効果を選択(名前/かな 入力で候補表示)',
    onChange: (value) => {
      updateSearchCondition();
      saveSearchCondition();
    },
  });

  wrapper.querySelector("#desired_count_"+idx).addEventListener("change", ()=> {
    updateSearchCondition();
    saveSearchCondition();
  });
  wrapper.querySelector("#desired_upto_"+idx).addEventListener("click", ()=> {
    const children = container.children;
    const index = Array.from(children).findIndex(e => e.id === wrapper.id);
    if (index === 0) return;
    container.insertBefore(children[index], children[index - 1]);
    resetEffectNumbers();
    updateSearchCondition();
    saveSearchCondition();
  });
  wrapper.querySelector("#desired_downto_"+idx).addEventListener("click", ()=> {
    const children = container.children;
    const index = Array.from(children).findIndex(e => e.id === wrapper.id);
    if (index === children.length - 1) return;
    container.insertBefore(children[index], children[index + 1].nextSibling);
    resetEffectNumbers();
    updateSearchCondition();
    saveSearchCondition();
  });
  wrapper.querySelector("#desired_remove_"+idx).addEventListener("click", ()=> {
    wrapper.remove();
    resetEffectNumbers();
    updateSearchCondition();
    saveSearchCondition();
  });
}

function renderDesiredRows(clear = false) {
  if (clear) {
    const container = document.getElementById("desiredList");
    container.innerHTML = "";
  }

  const cond = searchCondition[searchCondition.character_id] || {
      effect_ids: [0],
      effect_counts: [1],
      disadvantage_ids: [],
  };
  if (cond.effect_ids.length === 0) {
    addDesiredRow();
    return;
  }

  for (let i = 0; i < cond.effect_ids.length; i++) {
    addDesiredRow();

    const row = document.getElementById("desiredList").lastElementChild;

    const effectId = cond.effect_ids[i] ?? 0;
    if (effectId) {
      const selectDesired = row.querySelector("select[id^='desired_select_']");
      selectDesired.tomselect.setValue(effectId.toString(), true);
    }

    const count = cond.effect_counts[i] ?? 1;
    if (count > 1) {
      const selectCount = row.querySelector("select[id^='desired_count_']");
      selectCount.value = count;
    }
  }
}

/**
 * 探索対象遺物効果の初期化
 */
function initExcludedArea(){
  const container = document.getElementById("excludedList");
  container.innerHTML = "";
  document.querySelectorAll("#addExcludedBtn").forEach(e => e.addEventListener("click", () => {
    addExcludedRow();
    updateSearchCondition();
    saveSearchCondition();
  }));
  document.querySelectorAll("#resetExcludedBtn").forEach(e => e.addEventListener("click", () => {
    container.innerHTML = "";
    updateSearchCondition();
    saveSearchCondition();
  }));

  // 前回の設定を復元
  renderExcludedRows();
}

/**
 * 探索対象外デメリット効果の追加
 */
function addExcludedRow(){
  const container = document.getElementById("excludedList");
  if (container.children.length >= MAX_DISADVANTAGE_NUM) {
    return;
  }

  const idx = excludedRowIndex++;
  const wrapper = document.createElement("div");
  wrapper.className = "disadvantage-row";
  wrapper.style.position = "relative";
  wrapper.id = "excluded_row_"+idx;
  wrapper.innerHTML = `
    <select id="excluded_select_${idx}" placeholder="デメリットを選択(名前/かな 入力で候補表示)" style="flex:1" data-idx="${idx}"></select>
    <button class="btn-secondary" id="excluded_remove_${idx}">削除</button>
  `;
  container.appendChild(wrapper);
  new TomSelect(`select#excluded_select_${idx}`, {
    options: disadvantages,
    valueField: 'id',
    labelField: 'text',
    searchField: ['text', 'kana'],
    maxItems: 1,
    maxOptions: null,
    plugins: ['remove_button'],
    create: false,
    placeholder: 'デメリットを選択(名前/かな 入力で候補表示)',
    onChange: (value) => {
      updateSearchCondition();
      saveSearchCondition();
    },
  });

  wrapper.querySelector("#excluded_remove_"+idx).addEventListener("click", ()=> {
    wrapper.remove();
    updateSearchCondition();
    saveSearchCondition();
  });
}

function renderExcludedRows(clear = false) {
  if (clear) {
    const container = document.getElementById("excludedList");
    container.innerHTML = "";
  }

  const cond = searchCondition[searchCondition.character_id] || {
      effect_ids: [0],
      effect_counts: [1],
      disadvantage_ids: [],
  };
  if (cond.disadvantage_ids.length === 0) {
    return;
  }

  for (let i = 0; i < cond.disadvantage_ids.length; i++) {
    addExcludedRow();

    const row = document.getElementById("excludedList").lastElementChild;

    const disadvantageId = cond.disadvantage_ids[i] ?? 0;
    if (disadvantageId) {
      const selectExcluded = row.querySelector("select[id^='excluded_select_']");
      selectExcluded.tomselect.setValue(disadvantageId.toString(), true);
    }
  }
}

/* -----------------------
  Inventory (user relics) management
------------------------- */
function normalizeFullwidth(str) {
  return str.replace(/[A-Za-z0-9!-/:-@[-`{-~]/g, s =>
    String.fromCharCode(s.charCodeAt(0) + 0xFEE0)
  );
}

function filterRelics() {
  const q = (document.getElementById("inventorySearch").value || "").toLowerCase().trim();
  let filtered = userRelics;
  q.split(/\s/).forEach(_q => {
    filtered = filtered.filter(r=>{
      if(!r) return false;
      if(_q==="") return true;
      // ID
      if(_q.length === 26 && (r.id||"").toLowerCase().includes(_q)) return true;
      // 名前
      if((r.name||"").toLowerCase().includes(_q)) return true;
      // 効果
      const _Q = normalizeFullwidth(_q);
      if((r.effects||[]).some(e=>{
        return (
          (e?.text||"").toLowerCase().includes(_Q) ||
          (e?.kana||"").toLowerCase().includes(_Q)
        );
      })) return true;
      // デメリット
      if((r.disadvantages||[]).some(d=>{
        return (
          (d?.text||"").toLowerCase().includes(_Q) ||
          (d?.kana||"").toLowerCase().includes(_Q)
        );
      })) return true;
      // 色
      const color = (r.color.at(0) ?? "").toLowerCase();
      if(["r","g","b","y"].includes(_q) && color == _q) return true;
      // 大きさ
      const size = r.effects.filter(e => e?.id).length;
      if(["s","m","l"].includes(_q) && SIZE_MAP[_q] === size) return true;
      // 遺物種類
      const type = r.type.at(0) ?? "";
      if(["n","d"].includes(_q) && type === _q) return true;

      return false;
    });
  });
  return filtered;
}

function createRelicDiv(relic) {
  const div = document.createElement("div");
  const colorFirstLetter = relic.color ? relic.color[0] : "grey";
  div.classList.add("relic-item", `bg-${colorFirstLetter}`);
  const colorClass = `color-${colorFirstLetter}`;
  const deleteButton = relic.unique ? "" : `<button class="btn-secondary btn-del" data-id="${relic.id}">削除</button>`;
  const effectsAndDisadvantages = [];
  for (let i = 0; i < 3; i++) {
    const effect = relic.effects[i];
    const disadvantage = relic.disadvantages[i];
    if (!effect) {
      break;
    }
    effectsAndDisadvantages.push({
      effect: effect.text,
      disadvantage: disadvantage?.text || "",
    });
  }
  const effectList = effectsAndDisadvantages
    .map(e =>
      `<li>
        ${e.effect}<span class="disadvantage">${e.disadvantage ? "<br>" + e.disadvantage : ""}</span>
      </li>
      `
    )
    .join("")
  div.innerHTML = `
    <div style="flex:1">
      <div>
        <span class="color-chip ${colorClass}"></span>
        <strong>${relic.name}</strong>
        ${relic.unique?'<span class="muted small">（ユニーク）</span>':''}
        <span class="tiny">(${userRelics.indexOf(relic) + 1}: ${relic.id})</span>
      </div>
      <div class="small muted">
        <ul class="effect-list">
          ${effectList}
        </ul>
      </div>
    </div>
    <div style="display:flex;flex-direction:column;gap:6px">
      ${deleteButton}
    </div>
  `;
  return div;
}
function onClickRelicDelete() {
  const id = Number(b.dataset.id);
  if(confirm("本当にこの所持遺物を削除しますか？")){
    userRelics = userRelics.filter(x=>x.id!==id);
    saveUserRelics();
    renderRelics();
  }
}
function renderRelics(){
  const list = document.getElementById("inventoryList");
  list.innerHTML = "";
  if (userRelics.length === 0) {
    list.textContent = "(登録遺物0件)";
    return;
  }
  // allow search
  const filtered = filterRelics();
  if (filtered.length===0){
    list.textContent = "(該当なし)";
    return;
  }
  for(const r of filtered){
    list.appendChild(createRelicDiv(r));
  }
  // handlers
  list.querySelectorAll(".btn-del").forEach(b=>{
    b.addEventListener("click", onClickRelicDelete);
  });
}
document.getElementById("inventorySearch").addEventListener("input", renderRelics);

/* -----------------------
  Add relic modal handling
------------------------- */
document.getElementById("openAddRelic").addEventListener("click", ()=>{
  showImportRelicsModal();
});
function showImportRelicsModal(){
  const modal = document.getElementById("importRelicsModal");
  modal.style.display = "flex";
}
function clearImportCsvFile() {
  const fileInput = document.getElementById("relicsCsv");
  fileInput.value = "";
}
function closeRelicModal() {
  document.getElementById("importRelicsModal").style.display = "none";
}
document.querySelectorAll("#importRelicsModal, #r_cancel").forEach(e => e.addEventListener("click", (e)=> {
  if (!["importRelicsModal", "r_cancel"].includes(e.target.id)) return;
  closeRelicModal();
}));

/* -----------------------
  Search (探索) action
------------------------- */
const searchWorker = new Worker(`searchWorker.js?${Date.now()}`);
searchWorker.onmessage = function(e) {
  const data = e.data;

  if (data.progress) {
    renderProgress(data.progress)
  } else if (data.success) {
    const statusArea = document.getElementById("statusArea");
    const m = Math.floor(data.elapsed / 1000 / 60);
    const s = (data.elapsed / 1000 % 60).toFixed(3);
    const t = m > 0 ? `${m}分${s}秒` : `${s}秒`;
    statusArea.textContent = `探索完了: 所要時間 ${t}。結果はあくまで目安です。ビルド構築の参考にしてみてください。`;
    renderResults(data.results, data.desired);
    playCompletionSound();

    toggleSearching();
  } else {
    console.error(data.error);
    playErrorBeep();
    alert("探索中にエラーが発生しました: " + data.error);

    toggleSearching();
  }
};

function toggleSearching() {
  isSearching = !isSearching;
  document.querySelectorAll("#searchBtn, #clearResultsBtn")
    .forEach(btn => {
      if (isSearching) btn.setAttribute("disabled", "disabled");
      else btn.removeAttribute("disabled");
    })
}

function playCompletionSound() {
  const synth = new Tone.Synth().toDestination();
  const now = Tone.now();
  ["C5", "D5", "E5", "G5", "C6"].forEach((note, i) => {
    synth.triggerAttackRelease(note, "16n", now + i * 0.15);
  });
}

function playErrorBeep() {
  const synth = new Tone.Synth({
    oscillator: { type: "square" },
    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 }
  }).toDestination();

  const now = Tone.now();
  const notes = ["A4", "G4", "E4", "C4"]; // 少し暗めの下降進行
  const interval = 0.2; // 4音×0.2s ≒ 0.8s（完了音と同長）

  notes.forEach((note, i) => {
    synth.triggerAttackRelease(note, "16n", now + i * interval);
  });
}

document.getElementById("searchBtn").addEventListener("click", async ()=>{
  if (isSearching) return;

  try{
    const selected = document.querySelector('input[name="character"]:checked');
    if (!selected) return;
    const charId = Number(selected.value);

    // collect desired effects from rows
    const desiredRows = Array.from(document.querySelectorAll("#desiredList .effect-row"));
    const desired = [];
    for(const r of desiredRows){
      const selectDesired = r.querySelector("select[id^='desired_select_']");
      const selectCount = r.querySelector("select[id^='desired_count_']");
      if(!selectDesired) continue;
      const effId = Number(selectDesired.value.trim() || 0);
      if(!effId) continue;
      const effect = allEffects.find(e=> e.id === effId);
      if(!effect) {
        return;
      }
      const count = Number(selectCount.value || 1);
      for(let i=0;i<count;i++) desired.push(effect.id);
    }
    if(desired.length===0){ alert("欲しい遺物効果を1つ以上選んでください"); return; }
    if(desired.length>MAX_EFFECT_NUM){ alert(`欲しい効果は最大${MAX_EFFECT_NUM}個までです`); return; }

    const excludedRows = Array.from(document.querySelectorAll("#excludedList .disadvantage-row"));
    const excluded = [];
    for(const r of excludedRows){
      const selectDisadvantage = r.querySelector("select[id^='excluded_select_']");
      if(!selectDisadvantage) continue;
      const disId = Number(selectDisadvantage.value.trim() || 0);
      if(!disId) continue;
      const disadvantage = disadvantages.find(e=> e.id === disId);
      if(!disadvantage) {
        return;
      }
      excluded.push(disadvantage.id);
    }
    if(excluded.length>MAX_DISADVANTAGE_NUM){ alert(`除外デメリット効果は最大${MAX_DISADVANTAGE_NUM}個までです`); return; }

    // also we might want to include all unique relics as available even if user hasn't acquired them? the UI checkbox 'includeUnique' controls whether unique relics are used as pool.
    // prepare effectMap param for search
    let relicPool = userRelics.filter(r =>
      r.effects.some(e => desired.includes(e?.id))
    );
    if (excluded.length) {
      // デメリット効果で絞り込み
      relicPool = relicPool.filter(r =>
        r.disadvantages.map(d => d?.id).every(did => !excluded.includes(did))
      );
    }

    // invoke search
    document.getElementById("resultsArea").textContent = `探索中...`;
    await new Promise(r=>setTimeout(r,50));

    const char = characters.find(c=>c.id===charId);
    if(!char) throw new Error("character not found");
    const usableChalices = chalices.filter(ch=> (char.chalice_ids||[]).includes(ch.id));
    const _effectMap = {};
    Object.entries(effectMap).forEach(([key, value]) => {
      _effectMap[key] = {
        id: value?.id,
        group_id: value?.group_id ?? null,
        normal_id: value?.normal_id,
        depth_id: value?.depth_id,
        prefer_left: value?.prefer_left,
        level: value?.level ?? false,
        stack: value?.stack ?? false,
        disadvantage: value?.disadvantage ?? false,
      };
    });
    searchWorker.postMessage({
      startUnix: dayjs().valueOf(),
      chalices: usableChalices,
      relicPool,
      effectGroups,
      effectMap: _effectMap,
      desired,
      maxResults: 10,
    });

    toggleSearching();
  }catch(e){
    console.error(e);
    alert("探索中にエラーが発生しました: " + e.message);
  }
});

function renderProgress(progress) {
  const { chalices, chaliceIdx, slotIdx, foundResults, currentHighestReusults, desired, elapsed } = progress;
  const statusArea = document.getElementById("statusArea");
  const m = Math.floor(elapsed / 1000 / 60);
  const s = (elapsed / 1000 % 60).toFixed(3);
  const t = m > 0 ? `${m}分${s}秒` : `${s}秒`;
  statusArea.textContent =
    `探索中: 献器(${chalices[chaliceIdx].name}) ${chaliceIdx+1} / ${chalices.length}, スロット ${Math.min(slotIdx+1, 6)} / 6, 見つかった結果 ${foundResults}, 経過時間: ${t}`;
  if (currentHighestReusults.length) {
    renderResults(currentHighestReusults, desired);
  }
}

function renderResults(results, desired) {
  const area = document.getElementById("resultsArea");
  area.innerHTML = "";
  if(!results || results.length===0){
    area.textContent = "該当する組み合わせが見つかりませんでした。条件を見直してください。";
    return;
  }

  // sort already by score
  results.forEach((r, idx)=>{
    const card = document.createElement("div");
    card.className = "result-card";
    card.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>#${idx+1} ${r.chaliceName}</strong></div>
        <div><strong>${(r.score*100).toFixed(0)}%</strong> <span class="muted small">(${r.matched}/${r.desiredTotal})</span></div>
      </div>`;
    // show slots with color chips and relic names + effects
    const slotsDiv = document.createElement("div");
    slotsDiv.style.marginTop = "8px";
    const grid = document.createElement("div");
    grid.className = "grid-3";
    r.combo.forEach((slot,i)=>{
      const s = document.createElement("div");
      const slotColor = r.chaliceColors[i];
      s.classList.add(slotColor === "*" ? `bg-w` : `bg-${slotColor}`);
      s.style.border = "1px solid #ddd";
      s.style.padding = "6px";
      s.style.borderRadius = "6px";
      let colorClass = `color-${slotColor}`;
      if(!slot?.id){
        s.innerHTML = `
          <div class="muted small">スロット ${i+1}</div>
          <div style="display:flex;align-items:center;gap:8px">
            <span class="color-chip ${colorClass}"></span>
            <span>(空)</span>
          </div>
        `;
      } else {
        colorClass = `color-${slot.color[0]}`;
        let effectList = ``;
        for(let i=0;i<3;i++){
          const effect = (slot.effects || []).at(i);
          if (!effect) break;

          const advantageClass = desired.includes(effect.id) ? `advantage desired` : `advantage`;
          const disadvantage = (slot.disadvantages || []).at(i);
          let spanDisadvantage = ``;
          if (disadvantage) {
              spanDisadvantage = `
                <span class="disadvantage" data-disadvantage-id="${disadvantage.id}">
                  ${disadvantage ? "<br>" + disadvantage.text : ""}
                </span>
              `
          }
          effectList += `
            <li>
              <span class="${advantageClass}" data-effect-id="${effect.id}">${effect.text}</span>
              ${spanDisadvantage}
            </li>
          `
        }
        s.innerHTML = `
          <div class="muted small">スロット ${i+1}</div>
          <div style="display:flex;align-items:center;gap:8px">
            <span class="color-chip ${colorClass}"></span>
            <strong data-relic-id="${slot.id}">${slot.name ?? ""}</strong>
            <span class="tiny">(${slot.id})</span>
          </div>
          <div class="small muted" style="margin-top:6px">
            <ul class="effect-list">
              ${effectList}
            </ul>
          </div>
        `;
      }
      grid.appendChild(s);
    });
    slotsDiv.appendChild(grid);
    card.appendChild(slotsDiv);
    area.appendChild(card);
  });
}

document.getElementById("clearResultsBtn").addEventListener("click", ()=> {
  if (isSearching) return;
  document.getElementById("resultsArea").textContent = "結果をクリアしました";
});

/* initialize */
loadAll()
  .then(() => {
    renderWithData();
    document.getElementById("resultsArea").textContent = "準備完了。キャラ/効果/デメリット を設定し、探索開始ボタンを押してください。";
  }).catch(e => {
    console.error(e);
    document.getElementById("resultsArea").textContent = "読み込み失敗。コンソールを確認してください。";
  })

/* --- タブ切り替え処理 --- */
/**
 * localStorage の保存データ読み込み
 */
function loadActiveTab(){
  return localStorage.getItem(ACTIVE_TAB) ?? "usageTab";
}

/**
 * localStorage の保存データ読み込み
 */
function saveActiveTab(tab) {
  localStorage.setItem(
    ACTIVE_TAB,
    tab,
  );
}

document.addEventListener("DOMContentLoaded", () => {
  const tabButtons = document.querySelectorAll(".tab-btn");
  const tabContents = document.querySelectorAll(".tab-content");
  tabButtons.forEach(btn=>{
    btn.addEventListener("click", ()=>{
      tabButtons.forEach(b=>b.classList.remove("active"));
      tabContents.forEach(c=>c.classList.remove("active"));
      btn.classList.add("active");
      const nextTab = btn.dataset.tab;
      saveActiveTab(nextTab);
      document.getElementById(nextTab).classList.add("active");
    });
  });

  const initialTab = loadActiveTab();
  document.querySelector(`.tab-header .tab-btn[data-tab="${initialTab}"]`).click();
});

// Google Analytics
let gtag = () => {};
function insertScriptForGA() {
  if (isOptOutGA()) return;

  window.dataLayer = window.dataLayer || [];
  gtag = function(){dataLayer.push(arguments);};

  // スクリプト読み込み完了後に初期化
  const script = document.createElement("script");
  script.src = "https://www.googletagmanager.com/gtag/js?id=G-EKKVGVS0YV";
  script.async = true;
  script.onload = () => {
    gtag('js', new Date());
    gtag('config', 'G-EKKVGVS0YV', { anonymize_ip: true });
  };
  document.head.appendChild(script);
}
insertScriptForGA();

function isOptOutGA(){
  const url = new URL(location.href);
  const isNotProduction = (
    url.hostname !== "17number.github.io" ||
    !url.pathname.startsWith("/enr-relics-simulator")
  );
  return isNotProduction;
}
</script>
</body>
</html>
